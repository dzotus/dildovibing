# Redis - Документация компонента

## Обзор

Redis (Remote Dictionary Server) - это in-memory структура данных, используемая как база данных, кэш и брокер сообщений. Компонент Redis в системе симуляции полностью эмулирует поведение реального Redis, включая различные типы данных (string, hash, list, set, sorted set, stream), команды для работы с данными, TTL (Time To Live), управление памятью с политиками eviction, persistence (RDB/AOF), cluster mode, Pub/Sub, метрики производительности и полный набор команд Redis.

### Основные возможности

- ✅ **Типы данных** - String, Hash, List, Set, Sorted Set (ZSet), Stream
- ✅ **Команды Redis** - Полный набор команд для каждого типа данных
- ✅ **TTL (Time To Live)** - Автоматическое удаление ключей с истекшим временем жизни
- ✅ **Memory Management** - Управление памятью с 8 политиками eviction
- ✅ **Persistence** - RDB snapshots и AOF (Append Only File)
- ✅ **Cluster Mode** - Распределение данных по кластеру с slot-based routing (CRC16)
- ✅ **Pub/Sub** - Публикация и подписка на каналы с поддержкой паттернов
- ✅ **Метрики в реальном времени** - Полный набор метрик Redis (memory, operations, hit rate, slowlog, command statistics, network I/O)

---

## Основные функции

### 1. Управление Connection (Подключение)

**Описание:** Настройка подключения к Redis серверу.

**Параметры подключения:**
- **host** - Хост Redis сервера (по умолчанию: `localhost`)
- **port** - Порт Redis сервера (по умолчанию: `6379`)
- **password** - Пароль для аутентификации (опционально)
- **database** - Номер базы данных (0-15, по умолчанию: `0`)

**Пример конфигурации:**
```json
{
  "host": "localhost",
  "port": 6379,
  "password": "",
  "database": 0
}
```

### 2. Типы данных Redis

Redis поддерживает 6 основных типов данных:

#### 2.1. String (Строка)

**Описание:** Простейший тип данных - строка текста или бинарные данные.

**Команды:**
- **GET** - Получить значение ключа
- **SET** - Установить значение ключа
- **INCR, DECR** - Увеличить/уменьшить числовое значение на 1
- **INCRBY, DECRBY** - Увеличить/уменьшить на указанное число
- **APPEND** - Добавить строку к существующему значению
- **GETSET** - Получить старое значение и установить новое
- **MGET, MSET** - Получить/установить несколько ключей
- **STRLEN** - Получить длину строки
- **GETRANGE, SETRANGE** - Получить/установить часть строки

**Пример:**
```redis
SET user:1:name "John Doe"
GET user:1:name
INCR user:1:visits
```

#### 2.2. Hash (Хэш)

**Описание:** Хэш-таблица для хранения пар поле-значение.

**Команды:**
- **HSET** - Установить поле в хэше
- **HGET** - Получить значение поля
- **HMSET, HMGET** - Установить/получить несколько полей
- **HINCRBY, HINCRBYFLOAT** - Увеличить числовое значение поля
- **HEXISTS** - Проверить существование поля
- **HLEN** - Получить количество полей
- **HGETALL** - Получить все поля и значения
- **HDEL** - Удалить поля
- **HKEYS, HVALS** - Получить все ключи/значения

**Пример:**
```redis
HSET user:1 name "John" age 30 email "john@example.com"
HGET user:1 name
HGETALL user:1
```

#### 2.3. List (Список)

**Описание:** Двусвязный список строк, упорядоченный по порядку вставки.

**Команды:**
- **LPUSH, RPUSH** - Добавить элемент в начало/конец списка
- **LPOP, RPOP** - Удалить и вернуть элемент из начала/конца
- **LINDEX** - Получить элемент по индексу
- **LSET** - Установить значение элемента по индексу
- **LTRIM** - Обрезать список до указанного диапазона
- **LINSERT** - Вставить элемент перед/после указанного значения
- **RPOPLPUSH** - Переместить элемент из конца одного списка в начало другого
- **BLPOP, BRPOP** - Блокирующие операции (ожидание элемента)
- **LLEN** - Получить длину списка
- **LRANGE** - Получить диапазон элементов

**Пример:**
```redis
LPUSH tasks "task1" "task2" "task3"
LRANGE tasks 0 -1
LPOP tasks
```

#### 2.4. Set (Множество)

**Описание:** Неупорядоченная коллекция уникальных строк.

**Команды:**
- **SADD** - Добавить элементы в множество
- **SREM** - Удалить элементы из множества
- **SMEMBERS** - Получить все элементы множества
- **SISMEMBER** - Проверить принадлежность элемента
- **SCARD** - Получить количество элементов
- **SINTER, SUNION, SDIFF** - Пересечение, объединение, разность множеств
- **SINTERSTORE, SUNIONSTORE, SDIFFSTORE** - Сохранить результат операции
- **SMOVE** - Переместить элемент между множествами
- **SPOP** - Удалить и вернуть случайный элемент
- **SRANDMEMBER** - Получить случайный элемент без удаления

**Пример:**
```redis
SADD tags "redis" "database" "cache"
SMEMBERS tags
SISMEMBER tags "redis"
```

#### 2.5. Sorted Set (ZSet) (Упорядоченное множество)

**Описание:** Множество уникальных строк, отсортированных по числовому score.

**Команды:**
- **ZADD** - Добавить элемент с score
- **ZREM** - Удалить элементы
- **ZSCORE** - Получить score элемента
- **ZRANK, ZREVRANK** - Получить позицию элемента (по возрастанию/убыванию)
- **ZINCRBY** - Увеличить score элемента
- **ZCOUNT** - Подсчитать элементы в диапазоне score
- **ZRANGE, ZREVRANGE** - Получить элементы в диапазоне (по позиции)
- **ZRANGEBYSCORE, ZREVRANGEBYSCORE** - Получить элементы в диапазоне (по score)
- **ZREMRANGEBYSCORE, ZREMRANGEBYRANK** - Удалить элементы в диапазоне
- **ZCARD** - Получить количество элементов
- **ZUNIONSTORE, ZINTERSTORE** - Объединение/пересечение с сохранением результата

**Пример:**
```redis
ZADD leaderboard 100 "player1" 200 "player2" 150 "player3"
ZRANGE leaderboard 0 -1 WITHSCORES
ZREVRANGE leaderboard 0 2 WITHSCORES
```

#### 2.6. Stream (Поток)

**Описание:** Лог-структура данных для хранения упорядоченных записей с полями.

**Команды:**
- **XADD** - Добавить запись в поток
- **XREAD** - Читать записи из потока
- **XRANGE, XREVRANGE** - Получить записи в диапазоне ID
- **XREADGROUP** - Читать записи через consumer group
- **XACK** - Подтвердить обработку записи
- **XPENDING** - Получить информацию о pending записях
- **XCLAIM** - Забрать pending записи у другого consumer
- **XDEL** - Удалить записи
- **XTRIM** - Обрезать поток до указанной длины
- **XINFO** - Получить информацию о потоке и consumer groups

**Пример:**
```redis
XADD events * user_id 123 action "login" timestamp 1640000000
XREAD STREAMS events 0
XADD events * user_id 456 action "logout" timestamp 1640000001
```

### 3. TTL (Time To Live)

**Описание:** Автоматическое удаление ключей с истекшим временем жизни.

**Команды:**
- **EXPIRE** - Установить TTL в секундах
- **TTL** - Получить оставшееся время жизни
- **PERSIST** - Удалить TTL (сделать ключ постоянным)

**Параметры:**
- **ttl** - Время жизни в секундах (по умолчанию: `-1` - без истечения)
- **expiresAt** - Временная метка истечения (устанавливается автоматически)

**Пример:**
```redis
SET session:abc123 "data" EX 3600
TTL session:abc123
EXPIRE session:abc123 7200
```

### 4. Memory Management (Управление памятью)

**Описание:** Управление использованием памяти с политиками eviction при достижении лимита.

**Параметры:**
- **maxMemory** - Максимальный размер памяти (например, `256mb`, `1gb`, по умолчанию: `256mb`)
- **maxMemoryPolicy** - Политика eviction при достижении лимита (по умолчанию: `noeviction`)

**Политики eviction:**
- **noeviction** - Не удалять ключи, возвращать ошибку при попытке записи
- **allkeys-lru** - Удалять наименее используемые ключи (LRU)
- **allkeys-lfu** - Удалять наименее часто используемые ключи (LFU)
- **volatile-lru** - Удалять наименее используемые ключи с TTL (LRU)
- **volatile-lfu** - Удалять наименее часто используемые ключи с TTL (LFU)
- **volatile-ttl** - Удалять ключи с наименьшим оставшимся TTL
- **volatile-random** - Удалять случайные ключи с TTL
- **allkeys-random** - Удалять случайные ключи

**Пример конфигурации:**
```json
{
  "maxMemory": "512mb",
  "maxMemoryPolicy": "allkeys-lru"
}
```

### 5. Persistence (Персистентность)

**Описание:** Сохранение данных на диск для восстановления после перезапуска.

**Типы persistence:**
- **RDB** - Периодические snapshots (снимки) базы данных
- **AOF** - Append Only File - лог всех команд записи
- **both** - Комбинация RDB и AOF

**Параметры:**
- **enablePersistence** - Включить ли persistence (по умолчанию: `true`)
- **persistenceType** - Тип persistence: `rdb`, `aof`, `both` (по умолчанию: `rdb`)
- **rdbSaveInterval** - Интервалы сохранения RDB (например, `900 1 300 10 60 10000`)
- **aofRewritePolicy** - Политика перезаписи AOF: `always`, `everysec`, `no` (по умолчанию: `everysec`)

**Пример конфигурации:**
```json
{
  "enablePersistence": true,
  "persistenceType": "both",
  "rdbSaveInterval": "900 1 300 10 60 10000",
  "aofRewritePolicy": "everysec"
}
```

### 6. Cluster Mode (Кластерный режим)

**Описание:** Распределение данных по нескольким узлам Redis для горизонтального масштабирования.

**Параметры:**
- **enableCluster** - Включить ли cluster mode (по умолчанию: `false`)
- **clusterNodes** - Список узлов кластера (массив строк `host:port`)

**Как работает:**
- Данные распределяются по 16384 слотам (slots)
- Каждый ключ хэшируется через CRC16 для определения слота
- Каждый узел отвечает за определенный диапазон слотов
- Запросы автоматически направляются к нужному узлу

**Пример конфигурации:**
```json
{
  "enableCluster": true,
  "clusterNodes": [
    "localhost:6379",
    "localhost:6380",
    "localhost:6381"
  ]
}
```

### 7. Pub/Sub (Публикация/Подписка)

**Описание:** Механизм публикации сообщений в каналы и подписки на каналы.

**Команды:**
- **PUBLISH** - Опубликовать сообщение в канал
- **SUBSCRIBE** - Подписаться на канал
- **UNSUBSCRIBE** - Отписаться от канала
- **PSUBSCRIBE** - Подписаться на паттерн каналов
- **PUNSUBSCRIBE** - Отписаться от паттерна
- **PUBSUB** - Получить информацию о каналах и подписчиках

**Пример:**
```redis
PUBLISH notifications "New message"
SUBSCRIBE notifications
PSUBSCRIBE news:*
```

### 8. Команды для работы с ключами

**Команды:**
- **KEYS** - Получить все ключи по паттерну (не рекомендуется для production)
- **SCAN** - Итерация по ключам с курсором (рекомендуется)
- **EXISTS** - Проверить существование ключей
- **DEL** - Удалить ключи
- **RENAME, RENAMENX** - Переименовать ключ
- **TYPE** - Получить тип ключа
- **RANDOMKEY** - Получить случайный ключ
- **PERSIST** - Удалить TTL у ключа

**Пример:**
```redis
KEYS user:*
SCAN 0 MATCH user:* COUNT 100
EXISTS user:1
DEL user:1 user:2
TYPE user:1
```

### 9. Server Commands (Серверные команды)

**Команды:**
- **INFO** - Получить информацию о сервере
- **CONFIG GET/SET** - Получить/установить конфигурацию
- **CLIENT LIST** - Список подключенных клиентов
- **CLIENT KILL** - Отключить клиента
- **FLUSHDB** - Очистить текущую базу данных
- **FLUSHALL** - Очистить все базы данных
- **SAVE, BGSAVE** - Сохранить snapshot (синхронно/асинхронно)
- **LASTSAVE** - Время последнего сохранения

**Пример:**
```redis
INFO memory
CONFIG GET maxmemory
CLIENT LIST
FLUSHDB
```

---

## Руководство пользователя

### Быстрый старт

1. **Добавление компонента Redis:**
   - Перетащите компонент "Redis" из библиотеки компонентов на canvas
   - Откройте панель конфигурации компонента

2. **Настройка подключения:**
   - Перейдите на вкладку **"Configuration"**
   - Укажите host, port, password (опционально), database
   - Настройте maxMemory и maxMemoryPolicy

3. **Создание ключа:**
   - Перейдите на вкладку **"Keys"**
   - Нажмите кнопку **"Add Key"**
   - Укажите имя ключа, тип данных, значение, TTL (опционально)
   - Нажмите **"Save"**

4. **Выполнение команд:**
   - Перейдите на вкладку **"Commands"**
   - Введите команду Redis (например, `GET user:1`)
   - Нажмите **"Execute"** или Enter

### Работа с Keys

#### Создание ключа

1. Перейдите на вкладку **"Keys"**
2. Нажмите кнопку **"Add Key"**
3. Заполните параметры:
   - **Key Name** - Имя ключа (например, `user:1:name`)
   - **Type** - Тип данных (string, hash, list, set, zset, stream)
   - **Value** - Значение ключа (JSON для сложных типов)
   - **TTL** - Время жизни в секундах (опционально, `-1` для постоянного)
4. Нажмите **"Save"**

#### Поиск ключей

1. Введите паттерн поиска (например, `user:*`)
2. Нажмите Enter или кнопку поиска
3. Результаты отобразятся в таблице

**Примечание:** Используйте `SCAN` вместо `KEYS` для больших баз данных.

#### Редактирование ключа

1. Выберите ключ из списка
2. Нажмите кнопку **"Edit"** (иконка карандаша)
3. Измените значение или TTL
4. Нажмите **"Save"**

#### Удаление ключа

1. Выберите ключ из списка
2. Нажмите кнопку **"Delete"** (иконка корзины)
3. Подтвердите удаление

### Работа с Commands

#### Выполнение команд

1. Перейдите на вкладку **"Commands"**
2. Введите команду Redis:
   ```
   GET user:1
   SET user:1:name "John"
   HSET user:1 age 30
   ```
3. Нажмите **"Execute"** или Enter
4. Результат отобразится ниже

#### Примеры команд

**String:**
```redis
SET mykey "Hello"
GET mykey
INCR counter
APPEND mykey " World"
```

**Hash:**
```redis
HSET user:1 name "John" age 30
HGET user:1 name
HGETALL user:1
```

**List:**
```redis
LPUSH tasks "task1" "task2"
LRANGE tasks 0 -1
LPOP tasks
```

**Set:**
```redis
SADD tags "redis" "database"
SMEMBERS tags
SISMEMBER tags "redis"
```

**Sorted Set:**
```redis
ZADD leaderboard 100 "player1" 200 "player2"
ZRANGE leaderboard 0 -1 WITHSCORES
ZREVRANGE leaderboard 0 2
```

**Stream:**
```redis
XADD events * user_id 123 action "login"
XREAD STREAMS events 0
```

### Работа с Pub/Sub

#### Публикация сообщений

1. Перейдите на вкладку **"Pub/Sub"**
2. Введите имя канала (например, `notifications`)
3. Введите сообщение
4. Нажмите **"Publish"**

#### Подписка на каналы

1. Введите имя канала
2. Нажмите **"Subscribe"**
3. Сообщения в этом канале будут отображаться в реальном времени

#### Подписка на паттерны

1. Введите паттерн (например, `news:*`)
2. Нажмите **"Subscribe Pattern"**
3. Вы будете получать сообщения из всех каналов, соответствующих паттерну

#### Просмотр информации о каналах

- Список каналов с количеством подписчиков
- Список паттернов с количеством подписчиков
- Количество сообщений в каждом канале

### Работа с Cluster

#### Включение Cluster Mode

1. Перейдите на вкладку **"Cluster"**
2. Включите переключатель **"Enable Cluster"**
3. Добавьте узлы кластера (например, `localhost:6379`, `localhost:6380`)
4. Нажмите **"Save"**

**Примечание:** В симуляции все ключи обрабатываются одним узлом, но распределение по слотам симулируется.

---

## Руководство администратора

### Рекомендации по конфигурации

#### Production Redis

```json
{
  "host": "redis.production.internal",
  "port": 6379,
  "password": "***",
  "database": 0,
  "maxMemory": "2gb",
  "maxMemoryPolicy": "allkeys-lru",
  "enablePersistence": true,
  "persistenceType": "both",
  "rdbSaveInterval": "900 1 300 10 60 10000",
  "aofRewritePolicy": "everysec"
}
```

**Рекомендации:**
- Используйте сильные пароли
- Настройте maxMemory в зависимости от доступной памяти
- Используйте `allkeys-lru` или `allkeys-lfu` для кэширования
- Используйте `volatile-lru` или `volatile-ttl` для данных с TTL
- Включите persistence (RDB + AOF) для надежности
- Мониторьте метрики памяти и производительности

#### Оптимизация производительности

**Memory Management:**
- Установите `maxMemory` в зависимости от доступной памяти
- Выберите подходящую политику eviction:
  - **allkeys-lru** - для кэширования (удаление наименее используемых)
  - **allkeys-lfu** - для кэширования (удаление наименее часто используемых)
  - **volatile-lru** - для данных с TTL (удаление наименее используемых с TTL)
  - **volatile-ttl** - для данных с TTL (удаление с наименьшим TTL)
- Мониторьте `memoryUsagePercent` и `evictedKeys`

**Persistence:**
- Используйте `both` (RDB + AOF) для максимальной надежности
- Используйте `everysec` для AOF (баланс между производительностью и надежностью)
- Настройте `rdbSaveInterval` в зависимости от нагрузки
- Мониторьте влияние persistence на latency

**Ключи:**
- Используйте короткие имена ключей для экономии памяти
- Используйте TTL для временных данных
- Используйте `SCAN` вместо `KEYS` для больших баз данных
- Группируйте связанные данные в Hash или Sorted Set

**Команды:**
- Используйте pipeline для множественных команд
- Избегайте блокирующих команд (KEYS, FLUSHALL) в production
- Используйте `MGET/MSET` для множественных операций
- Используйте `EXISTS` для проверки существования перед операциями

### Безопасность

#### Управление доступом

- Используйте сильные пароли
- Не храните пароли в открытом виде в конфигурации
- Используйте переменные окружения для паролей
- Ограничьте доступ к Redis только необходимым приложениям
- Используйте firewall для ограничения доступа по сети

#### Защита данных

- Используйте TTL для временных данных
- Регулярно делайте backup (RDB snapshots)
- Мониторьте использование памяти
- Настройте алерты при достижении лимитов памяти

### Мониторинг и алертинг

#### Ключевые метрики

1. **Memory Usage Percent**
   - Нормальное значение: < 80%
   - Алерт: memory usage > 90% (риск eviction или ошибок)

2. **Operations Per Second**
   - Нормальное значение: зависит от нагрузки
   - Алерт: резкое падение или превышение порога

3. **Hit Rate**
   - Нормальное значение: > 95% для кэширования
   - Алерт: hit rate < 90% (неэффективное кэширование)

4. **Evicted Keys**
   - Нормальное значение: 0 (если не используется eviction)
   - Алерт: большое количество evicted keys (недостаточно памяти)

5. **Expired Keys**
   - Нормальное значение: зависит от использования TTL
   - Алерт: необычно большое количество (проверить TTL настройки)

6. **Connected Clients**
   - Нормальное значение: зависит от нагрузки
   - Алерт: резкое увеличение (возможная утечка соединений)

7. **Slowlog**
   - Нормальное значение: пустой или редкие записи
   - Алерт: частые медленные команды (> 10ms)

8. **Network I/O**
   - Нормальное значение: зависит от нагрузки
   - Алерт: резкое увеличение (возможная атака или утечка)

---

## Метрики и мониторинг

### Основные метрики

#### Throughput
- **Описание:** Количество операций в секунду
- **Единица измерения:** operations/sec
- **Источник:** Рассчитывается из истории операций за последнюю секунду

#### Memory Usage
- **Описание:** Использование памяти
- **Единица измерения:** bytes, процент от maxMemory
- **Факторы влияния:**
  - Количество ключей
  - Размер значений
  - Типы данных
  - TTL ключей

#### Hit Rate
- **Описание:** Процент успешных операций GET (cache hit)
- **Единица измерения:** процент (0-1)
- **Расчет:** hitCount / (hitCount + missCount)
- **Нормальное значение:** > 95% для кэширования

#### Error Rate
- **Описание:** Процент ошибок при выполнении операций
- **Единица измерения:** процент (0-1)
- **Причины ошибок:**
  - Memory limit exceeded (eviction policy)
  - Неверные команды
  - Несуществующие ключи (для некоторых операций)

### Метрики Keys

- **totalKeys** - Общее количество ключей
- **keysByType** - Количество ключей по типам (string, hash, list, set, zset, stream)

### Метрики Memory

- **memoryUsage** - Используемая память (bytes)
- **memoryUsagePercent** - Процент использования памяти (0-100)
- **evictedKeys** - Количество удаленных ключей из-за eviction
- **expiredKeys** - Количество истекших ключей

### Метрики Operations

- **operationsPerSecond** - Операций в секунду
- **hitCount** - Количество успешных GET операций
- **missCount** - Количество неуспешных GET операций
- **hitRate** - Процент попаданий (hitCount / (hitCount + missCount))

### Метрики Clients

- **connectedClients** - Количество подключенных клиентов
- **connectedClientsDetail** - Детальная информация о клиентах (id, addr, age, idle, cmd)

### Метрики Performance

- **slowlog** - Список медленных команд (команды, выполнявшиеся дольше порога)
- **commandStatistics** - Статистика по командам (calls, totalDuration, averageDuration)
- **networkBytesIn** - Входящий сетевой трафик (bytes)
- **networkBytesOut** - Исходящий сетевой трафик (bytes)

### Мониторинг в реальном времени

Все метрики обновляются в реальном времени во время симуляции:
- Метрики синхронизируются из `RedisRoutingEngine` каждые 500ms
- Метрики отображаются в UI компоненте
- История операций хранится для расчета метрик
- Slowlog обновляется автоматически для команд, превышающих порог

---

## Примеры использования

### Пример 1: Простое кэширование

**Сценарий:** Кэширование данных пользователя

```json
{
  "host": "localhost",
  "port": 6379,
  "database": 0,
  "maxMemory": "256mb",
  "maxMemoryPolicy": "allkeys-lru",
  "keys": [
    {
      "key": "user:1",
      "type": "hash",
      "ttl": 3600,
      "value": {
        "name": "John Doe",
        "email": "john@example.com",
        "age": 30
      }
    }
  ]
}
```

**Команды:**
```redis
HSET user:1 name "John Doe" email "john@example.com" age 30
EXPIRE user:1 3600
HGETALL user:1
```

### Пример 2: Счетчики и рейтинги

**Сценарий:** Leaderboard с использованием Sorted Set

```json
{
  "keys": [
    {
      "key": "leaderboard",
      "type": "zset",
      "value": [
        { "member": "player1", "score": 100 },
        { "member": "player2", "score": 200 },
        { "member": "player3", "score": 150 }
      ]
    }
  ]
}
```

**Команды:**
```redis
ZADD leaderboard 100 player1 200 player2 150 player3
ZREVRANGE leaderboard 0 9 WITHSCORES
ZINCRBY leaderboard 50 player1
```

### Пример 3: Очередь задач

**Сценарий:** Очередь задач с использованием List

```json
{
  "keys": [
    {
      "key": "tasks:queue",
      "type": "list",
      "value": ["task1", "task2", "task3"]
    }
  ]
}
```

**Команды:**
```redis
LPUSH tasks:queue "task1" "task2" "task3"
RPOP tasks:queue
LLEN tasks:queue
```

### Пример 4: Pub/Sub уведомления

**Сценарий:** Система уведомлений

```redis
# Publisher
PUBLISH notifications "New message for user:123"

# Subscriber
SUBSCRIBE notifications

# Pattern subscriber
PSUBSCRIBE notifications:*
```

### Пример 5: Production конфигурация

**Сценарий:** Production Redis с persistence и cluster

```json
{
  "host": "redis.production.internal",
  "port": 6379,
  "password": "***",
  "database": 0,
  "maxMemory": "2gb",
  "maxMemoryPolicy": "allkeys-lru",
  "enablePersistence": true,
  "persistenceType": "both",
  "rdbSaveInterval": "900 1 300 10 60 10000",
  "aofRewritePolicy": "everysec",
  "enableCluster": true,
  "clusterNodes": [
    "redis1.internal:6379",
    "redis2.internal:6379",
    "redis3.internal:6379"
  ]
}
```

---

## Часто задаваемые вопросы (FAQ)

### Что такое Redis?

Redis (Remote Dictionary Server) - это in-memory структура данных, используемая как база данных, кэш и брокер сообщений. Redis хранит данные в памяти для максимальной производительности.

### В чем разница между Redis и традиционными базами данных?

- **Хранение:** Redis хранит данные в памяти (RAM), традиционные БД - на диске
- **Производительность:** Redis значительно быстрее благодаря работе в памяти
- **Типы данных:** Redis поддерживает специализированные структуры данных (hash, list, set, zset, stream)
- **Персистентность:** Redis опционально сохраняет данные на диск, но основная работа - в памяти

### Когда использовать Redis?

- **Кэширование** - Кэширование часто используемых данных
- **Счетчики** - Реализация счетчиков и рейтингов
- **Очереди** - Очереди задач и сообщений
- **Pub/Sub** - Публикация и подписка на события
- **Session storage** - Хранение сессий пользователей
- **Real-time analytics** - Аналитика в реальном времени

### Как работает TTL в Redis?

TTL (Time To Live) - это время жизни ключа в секундах. После истечения TTL ключ автоматически удаляется. Используйте `EXPIRE` для установки TTL и `TTL` для проверки оставшегося времени.

### Что такое eviction policy?

Eviction policy определяет, какие ключи удалять при достижении лимита памяти (`maxMemory`). Популярные политики:
- **allkeys-lru** - Удалять наименее используемые ключи
- **allkeys-lfu** - Удалять наименее часто используемые ключи
- **volatile-ttl** - Удалять ключи с наименьшим TTL

### Как работает Redis Cluster?

Redis Cluster распределяет данные по 16384 слотам (slots). Каждый ключ хэшируется через CRC16 для определения слота. Каждый узел отвечает за определенный диапазон слотов. Запросы автоматически направляются к нужному узлу.

### Как мониторить производительность Redis?

Используйте метрики в реальном времени:
- Memory Usage Percent, Operations Per Second, Hit Rate
- Evicted Keys, Expired Keys, Connected Clients
- Slowlog, Command Statistics, Network I/O

### Как оптимизировать Redis?

1. Используйте короткие имена ключей
2. Используйте подходящие типы данных (Hash вместо множества String ключей)
3. Используйте TTL для временных данных
4. Настройте подходящую политику eviction
5. Используйте pipeline для множественных команд
6. Мониторьте использование памяти и производительность

---

## Дополнительные ресурсы

- [Официальная документация Redis](https://redis.io/docs/)
- [Redis Commands Reference](https://redis.io/commands/)
- [Redis Best Practices](https://redis.io/docs/manual/patterns/)
- [Redis Performance Tuning](https://redis.io/docs/manual/optimization/)
