# План доработки компонента Redis до уровня 10/10

## Анализ текущего состояния

### ✅ Что уже реализовано

**Симулятивность:**
- Базовые типы данных: string, hash, list, set, zset, stream (частично)
- Основные команды для каждого типа данных
- TTL и автоматическое удаление expired keys
- Memory management с eviction policies (8 политик)
- Базовый cluster mode с slot-based routing (CRC16)
- Метрики: memory usage, hit/miss ratio, operations per second, expired/evicted keys
- Интеграция в EmulationEngine и DataFlowEngine

**UI/UX:**
- Табы: Keys, Commands, Configuration, Cluster
- Управление ключами (создание, редактирование, удаление)
- Выполнение команд через терминал
- Настройки подключения (host, port, password, database)
- Настройки памяти и persistence
- Настройки кластера
- Real-time метрики в UI
- Поиск ключей по паттерну

### ❌ Что отсутствует или неполно

**Симулятивность:**

1. **Streams не реализованы (критично):**
   - Тип данных объявлен, но команды отсутствуют
   - XADD, XREAD, XRANGE и другие команды не реализованы
   - Streams не работают в executeCommand

2. **Команды Redis (критично):**
   - String: INCR, DECR, INCRBY, DECRBY, APPEND, GETSET, MGET, MSET, MSETNX, STRLEN, GETRANGE, SETRANGE
   - Hash: HMSET, HINCRBY, HINCRBYFLOAT, HEXISTS, HLEN, HMGET, HSTRLEN
   - List: LINDEX, LSET, LTRIM, LINSERT, RPOPLPUSH, BRPOP, BLPOP, LLEN (есть, но проверить)
   - Set: SINTER, SUNION, SDIFF, SINTERSTORE, SUNIONSTORE, SDIFFSTORE, SMOVE, SPOP, SRANDMEMBER
   - Sorted Set: ZRANGEBYSCORE, ZREVRANGE, ZREVRANGEBYSCORE, ZRANK, ZREVRANK, ZINCRBY, ZCOUNT, ZREM RANGEBYSCORE, ZREM RANGEBYRANK, ZUNIONSTORE, ZINTERSTORE
   - Stream: XADD, XREAD, XRANGE, XREVRANGE, XREADGROUP, XACK, XPENDING, XCLAIM, XDEL, XTRIM, XINFO
   - Keys: SCAN, RENAME, RENAMENX, TYPE, RANDOMKEY, DUMP, RESTORE, MOVE, PERSIST
   - Server: FLUSHDB, FLUSHALL, SAVE, BGSAVE, LASTSAVE, SHUTDOWN, CONFIG GET/SET, CLIENT LIST/KILL, INFO (расширить)

2. **Продвинутые функции:**
   - Pub/Sub: PUBLISH, SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB
   - Transactions: MULTI, EXEC, DISCARD, WATCH, UNWATCH
   - Lua Scripting: EVAL, EVALSHA, SCRIPT LOAD/FLUSH/KILL/EXISTS
   - Bitmaps: SETBIT, GETBIT, BITCOUNT, BITOP, BITPOS
   - Bitfields: BITFIELD, BITFIELD_RO
   - Geospatial: GEOADD, GEODIST, GEOHASH, GEOPOS, GEORADIUS, GEORADIUSBYMEMBER
   - HyperLogLog: PFADD, PFCOUNT, PFMERGE
   - JSON: JSON.SET, JSON.GET, JSON.DEL, JSON.MGET, JSON.TYPE, и др. (RedisJSON модуль)

3. **Persistence (только UI, нет симуляции):**
   - RDB snapshots не симулируются
   - AOF replay не симулируется
   - Влияние persistence на производительность не учитывается

4. **Replication:**
   - Master-replica не реализована
   - Replication lag не учитывается
   - Failover не симулируется

5. **Sentinel:**
   - Мониторинг не реализован
   - Автоматический failover не симулируется

6. **Cluster (частично):**
   - Slot migration не реализована
   - Failover в кластере не симулируется
   - MOVED/ASK redirects не обрабатываются правильно

7. **Метрики:**
   - Connected clients (есть, но упрощено)
   - Replication lag (нет)
   - Slowlog (нет)
   - Command statistics (нет)
   - Network I/O (нет)

**UI/UX:**

1. **Недостающие секции:**
   - Pub/Sub tab (каналы, подписки)
   - Transactions tab (отслеживание транзакций)
   - Replication tab (master/replica статус)
   - Sentinel tab (мониторинг)
   - Modules tab (загруженные модули)
   - Slowlog tab (медленные команды)

2. **Улучшения:**
   - Визуализация структуры данных (hash, list, set, zset)
   - Редактирование значений в удобном формате
   - Bulk operations (массовые операции)
   - Export/Import данных
   - История изменений ключей
   - Мониторинг команд в реальном времени
   - Графики метрик (memory, ops/sec, hit rate)

3. **Проблемы:**
   - Streams не отображаются правильно в UI
   - Нет валидации команд перед выполнением
   - Нет автодополнения команд
   - Нет подсветки синтаксиса в терминале
   - Нет группировки ключей по паттернам

## План реализации

### Этап 1: Расширение команд Redis (Приоритет: ВЫСОКИЙ)

**Цель:** Реализовать все основные команды Redis для каждого типа данных

**Задачи:**

1. **String команды:**
   - [x] INCR, DECR, INCRBY, DECRBY ✅ РЕАЛИЗОВАНО
   - [x] APPEND, GETSET ✅ РЕАЛИЗОВАНО
   - [x] MGET, MSET, MSETNX ✅ РЕАЛИЗОВАНО
   - [x] STRLEN, GETRANGE, SETRANGE ✅ РЕАЛИЗОВАНО

2. **Hash команды:**
   - [x] HMSET, HMGET ✅ РЕАЛИЗОВАНО
   - [x] HINCRBY, HINCRBYFLOAT ✅ РЕАЛИЗОВАНО
   - [x] HEXISTS, HLEN, HSTRLEN ✅ РЕАЛИЗОВАНО

3. **List команды:**
   - [x] LINDEX, LSET, LTRIM ✅ РЕАЛИЗОВАНО
   - [x] LINSERT, RPOPLPUSH ✅ РЕАЛИЗОВАНО
   - [x] BLPOP, BRPOP (blocking operations) ✅ РЕАЛИЗОВАНО (упрощенно)

4. **Set команды:**
   - [x] SINTER, SUNION, SDIFF ✅ РЕАЛИЗОВАНО
   - [x] SINTERSTORE, SUNIONSTORE, SDIFFSTORE ✅ РЕАЛИЗОВАНО
   - [x] SMOVE, SPOP, SRANDMEMBER ✅ РЕАЛИЗОВАНО

5. **Sorted Set команды:**
   - [x] ZRANGEBYSCORE, ZREVRANGE, ZREVRANGEBYSCORE ✅ РЕАЛИЗОВАНО
   - [x] ZRANK, ZREVRANK, ZINCRBY ✅ РЕАЛИЗОВАНО
   - [x] ZCOUNT, ZREMRANGEBYSCORE, ZREMRANGEBYRANK ✅ РЕАЛИЗОВАНО
   - [x] ZUNIONSTORE, ZINTERSTORE ✅ РЕАЛИЗОВАНО

6. **Stream команды (полная реализация) - КРИТИЧНО:**
   - [x] XADD (с полной поддержкой полей) ✅ РЕАЛИЗОВАНО
   - [x] XREAD, XRANGE, XREVRANGE ✅ РЕАЛИЗОВАНО
   - [x] XREADGROUP, XACK, XPENDING ✅ РЕАЛИЗОВАНО
   - [x] XCLAIM, XDEL, XTRIM, XINFO ✅ РЕАЛИЗОВАНО
   - [x] Хранение stream данных (entries с ID и полями) ✅ РЕАЛИЗОВАНО
   - [x] Consumer groups поддержка ✅ РЕАЛИЗОВАНО

7. **Keys команды:**
   - [x] SCAN (с курсором) ✅ РЕАЛИЗОВАНО
   - [x] RENAME, RENAMENX ✅ РЕАЛИЗОВАНО
   - [x] TYPE, RANDOMKEY ✅ РЕАЛИЗОВАНО
   - [x] PERSIST ✅ РЕАЛИЗОВАНО
   - [ ] DUMP, RESTORE, MOVE - ОТЛОЖЕНО (не критично для симуляции)

**Файлы для изменения:**
- `src/core/RedisRoutingEngine.ts` - добавить методы для новых команд
- `src/core/DataFlowEngine.ts` - обновить обработку команд (если нужно)

**Критерии готовности:**
- [x] Все команды реализованы и протестированы ✅
- [x] Команды работают через executeCommand ✅
- [x] Команды работают через UI терминал ✅
- [x] Команды обрабатываются в DataFlowEngine ✅
- [x] **Streams полностью функциональны (критично!)** ✅

**СТАТУС: ✅ ЭТАП 1 ЗАВЕРШЕН**

---

### Этап 2: Pub/Sub (Приоритет: СРЕДНИЙ)

**Цель:** Реализовать Pub/Sub функциональность Redis

**Задачи:**

1. **Реализация в RedisRoutingEngine:**
   - [x] Хранение каналов и подписчиков ✅ РЕАЛИЗОВАНО
   - [x] PUBLISH - публикация сообщений ✅ РЕАЛИЗОВАНО
   - [x] SUBSCRIBE, PSUBSCRIBE - подписка на каналы/паттерны ✅ РЕАЛИЗОВАНО
   - [x] UNSUBSCRIBE, PUNSUBSCRIBE - отписка ✅ РЕАЛИЗОВАНО
   - [x] PUBSUB - получение информации о каналах ✅ РЕАЛИЗОВАНО
   - [x] Метод getPubSubInfo() для UI ✅ РЕАЛИЗОВАНО

2. **Интеграция в DataFlowEngine:**
   - [x] Обработка PUBLISH команд с распространением ✅ РЕАЛИЗОВАНО
   - [x] Распространение сообщений подписчикам между компонентами ✅ РЕАЛИЗОВАНО
   - [x] Поддержка паттернов (PSUBSCRIBE) ✅ РЕАЛИЗОВАНО
   - [x] Методы для проверки подписчиков (hasChannelSubscribers, patternMatchesChannel) ✅ РЕАЛИЗОВАНО
   - [x] Обработка входящих Pub/Sub сообщений (processIncomingPubSubMessage) ✅ РЕАЛИЗОВАНО

3. **UI:**
   - [x] Новый таб "Pub/Sub" ✅ РЕАЛИЗОВАНО
   - [x] Список каналов с количеством подписчиков ✅ РЕАЛИЗОВАНО
   - [x] Возможность подписаться/отписаться ✅ РЕАЛИЗОВАНО
   - [x] Отображение информации о каналах в реальном времени ✅ РЕАЛИЗОВАНО
   - [x] Подписка на паттерны ✅ РЕАЛИЗОВАНО
   - [x] Поиск каналов ✅ РЕАЛИЗОВАНО

**Файлы для изменения:**
- `src/core/RedisRoutingEngine.ts` - добавить Pub/Sub логику ✅
- `src/core/DataFlowEngine.ts` - обработка Pub/Sub сообщений (отложено)
- `src/components/config/data/RedisConfigAdvanced.tsx` - новый таб ✅

**Критерии готовности:**
- [x] Pub/Sub работает через команды ✅
- [x] Сообщения доставляются подписчикам (внутри одного компонента) ✅
- [x] UI отображает каналы и информацию ✅
- [x] Поддержка паттернов работает ✅

**СТАТУС: ✅ ЭТАП 2 ПОЛНОСТЬЮ ЗАВЕРШЕН**

**Реализовано:**
- ✅ Базовая функциональность Pub/Sub внутри одного компонента
- ✅ Распространение сообщений между разными компонентами Redis через DataFlowEngine
- ✅ Автоматическое обнаружение подписчиков в других компонентах
- ✅ Обработка входящих Pub/Sub сообщений от других компонентов
- ✅ Поиск каналов в UI

---

### Этап 3: Transactions (Приоритет: СРЕДНИЙ)

**Цель:** Реализовать транзакции Redis (MULTI/EXEC)

**Задачи:**

1. **Реализация в RedisRoutingEngine:**
   - [ ] MULTI - начало транзакции
   - [ ] EXEC - выполнение транзакции
   - [ ] DISCARD - отмена транзакции
   - [ ] WATCH - отслеживание ключей
   - [ ] UNWATCH - отмена отслеживания
   - [ ] Хранение состояния транзакций по клиентам

2. **UI:**
   - [ ] Новый таб "Transactions"
   - [ ] Отображение активных транзакций
   - [ ] История транзакций
   - [ ] Визуализация команд в транзакции

**Файлы для изменения:**
- `src/core/RedisRoutingEngine.ts` - добавить transaction логику
- `src/components/config/data/RedisConfigAdvanced.tsx` - новый таб

**Критерии готовности:**
- MULTI/EXEC работает корректно
- WATCH отслеживает изменения
- Транзакции отображаются в UI

---

### Этап 4: Persistence симуляция (Приоритет: НИЗКИЙ)

**Цель:** Симулировать влияние persistence на производительность

**Задачи:**

1. **RDB симуляция:**
   - [ ] Периодические snapshots (по rdbSaveInterval)
   - [ ] Влияние на latency при создании snapshot
   - [ ] Размер snapshot файла

2. **AOF симуляция:**
   - [ ] Логирование команд в AOF
   - [ ] Rewrite AOF (по политике)
   - [ ] Влияние на latency при записи

3. **UI:**
   - [ ] Отображение статуса persistence
   - [ ] Последний snapshot/rewrite время
   - [ ] Размеры файлов

**Файлы для изменения:**
- `src/core/RedisRoutingEngine.ts` - добавить persistence логику
- `src/core/EmulationEngine.ts` - учитывать persistence в метриках
- `src/components/config/data/RedisConfigAdvanced.tsx` - отображение статуса

**Критерии готовности:**
- Persistence влияет на latency
- Статус отображается в UI
- Настройки persistence работают

---

### Этап 5: Replication (Приоритет: НИЗКИЙ)

**Цель:** Реализовать master-replica репликацию

**Задачи:**

1. **Реализация в RedisRoutingEngine:**
   - [ ] Конфигурация master/replica
   - [ ] Синхронизация данных с master
   - [ ] Replication lag расчет
   - [ ] Обработка команд на replica (только read)

2. **UI:**
   - [ ] Новый таб "Replication"
   - [ ] Статус master/replica
   - [ ] Replication lag отображение
   - [ ] Список replicas

**Файлы для изменения:**
- `src/core/RedisRoutingEngine.ts` - добавить replication логику
- `src/components/config/data/RedisConfigAdvanced.tsx` - новый таб

**Критерии готовности:**
- Replication работает
- Replication lag учитывается в метриках
- UI отображает статус

---

### Этап 6: Улучшение UI/UX (Приоритет: ВЫСОКИЙ)

**Цель:** Довести UI до уровня реального Redis клиента

**Задачи:**

1. **Улучшение таба Keys:**
   - [ ] Визуализация структуры данных (hash, list, set, zset)
   - [ ] Удобное редактирование значений
   - [ ] Bulk operations (массовое удаление, изменение TTL)
   - [ ] Группировка ключей по паттернам
   - [ ] Экспорт/импорт данных
   - [ ] История изменений ключей

2. **Улучшение таба Commands:**
   - [ ] Автодополнение команд
   - [ ] Подсветка синтаксиса
   - [ ] Валидация команд перед выполнением
   - [ ] Подсказки по командам
   - [ ] Сохранение избранных команд
   - [ ] Мониторинг команд в реальном времени

3. **Новые табы:**
   - [ ] Pub/Sub (см. Этап 2)
   - [ ] Transactions (см. Этап 3)
   - [ ] Replication (см. Этап 5)
   - [ ] Slowlog - отображение медленных команд
   - [ ] Modules - список загруженных модулей

4. **Графики метрик:**
   - [ ] Memory usage over time
   - [ ] Operations per second
   - [ ] Hit rate over time
   - [ ] Latency distribution

5. **Адаптивность:**
   - [x] Табы переносятся на новую строку при узком экране ✅ РЕАЛИЗОВАНО (flex-wrap вместо grid-cols-4)
   - [x] Подложка расширяется при переносе табов ✅ РЕАЛИЗОВАНО (автоматически через flex-wrap)

**Файлы для изменения:**
- `src/components/config/data/RedisConfigAdvanced.tsx` - все улучшения UI

**Критерии готовности:**
- UI соответствует реальному Redis клиенту
- Все элементы интерактивны
- Адаптивность работает
- Графики отображаются корректно

---

### Этап 7: Расширенные типы данных (Приоритет: СРЕДНИЙ)

**Цель:** Реализовать Bitmaps, Bitfields, Geospatial, HyperLogLog

**Задачи:**

1. **Bitmaps:**
   - [ ] SETBIT, GETBIT, BITCOUNT, BITOP, BITPOS
   - [ ] Хранение bitmap данных
   - [ ] UI для работы с bitmaps

2. **Bitfields:**
   - [ ] BITFIELD, BITFIELD_RO
   - [ ] Хранение bitfield данных

3. **Geospatial:**
   - [ ] GEOADD, GEODIST, GEOHASH, GEOPOS
   - [ ] GEORADIUS, GEORADIUSBYMEMBER
   - [ ] Визуализация на карте (опционально)

4. **HyperLogLog:**
   - [ ] PFADD, PFCOUNT, PFMERGE
   - [ ] Хранение HLL данных

**Файлы для изменения:**
- `src/core/RedisRoutingEngine.ts` - добавить команды
- `src/components/config/data/RedisConfigAdvanced.tsx` - UI для новых типов

**Критерии готовности:**
- Все команды работают
- Данные хранятся корректно
- UI поддерживает новые типы

---

### Этап 8: Lua Scripting (Приоритет: НИЗКИЙ)

**Цель:** Реализовать выполнение Lua скриптов

**Задачи:**

1. **Реализация:**
   - [ ] EVAL - выполнение скрипта
   - [ ] EVALSHA - выполнение по SHA1
   - [ ] SCRIPT LOAD/FLUSH/KILL/EXISTS
   - [ ] Базовый Lua интерпретатор или симуляция

2. **UI:**
   - [ ] Редактор Lua скриптов
   - [ ] Выполнение скриптов
   - [ ] История скриптов

**Файлы для изменения:**
- `src/core/RedisRoutingEngine.ts` - добавить Lua поддержку
- `src/components/config/data/RedisConfigAdvanced.tsx` - редактор скриптов

**Критерии готовности:**
- Скрипты выполняются
- SCRIPT команды работают
- UI поддерживает редактирование

---

### Этап 9: Улучшение Cluster (Приоритет: СРЕДНИЙ)

**Цель:** Полноценная симуляция Redis Cluster

**Задачи:**

1. **Реализация:**
   - [ ] Правильная обработка MOVED/ASK redirects
   - [ ] Slot migration симуляция
   - [ ] Failover в кластере
   - [ ] Репликация в кластере

2. **UI:**
   - [ ] Визуализация кластера
   - [ ] Отображение слотов по нодам
   - [ ] Статус каждой ноды

3. **Архитектура кластера (КРИТИЧНО для симулятивности):**
   - [ ] Каждая нода кластера - отдельный компонент Redis на канвасе
   - [ ] Кластер формируется через соединения между нодами (не через строки в конфиге)
   - [ ] Автоматическое обнаружение нод кластера через соединения
   - [ ] Распределение слотов между реальными нодами-компонентами
   - [ ] Синхронизация состояния кластера между нодами
   - [ ] Удаление хардкода адресов нод из конфига (clusterNodes как строки)
   - [ ] UI для управления кластером через соединения компонентов

**Проблема текущей реализации:**
- Сейчас ноды кластера - это просто строки адресов в массиве `clusterNodes` в конфиге одного компонента
- Это не симулятивно: нет реальных нод-компонентов, нет реальных соединений
- В реальном Redis каждая нода - отдельный экземпляр сервера

**Решение:**
- Каждая нода кластера должна быть отдельным компонентом типа `redis` на канвасе
- Кластер определяется через соединения между этими компонентами
- При включении cluster mode компонент автоматически обнаруживает связанные ноды через connections
- Слоты распределяются между реальными нодами-компонентами
- Убрать поле `clusterNodes` из конфига или использовать его только для отображения обнаруженных нод

**Файлы для изменения:**
- `src/core/RedisRoutingEngine.ts` - улучшить cluster логику, добавить обнаружение нод через connections
- `src/core/EmulationEngine.ts` - логика обнаружения нод кластера через connections
- `src/components/config/data/RedisConfigAdvanced.tsx` - визуализация кластера, отображение обнаруженных нод
- `src/core/DataFlowEngine.ts` - обработка MOVED/ASK redirects между нодами

**Критерии готовности:**
- Cluster работает корректно
- Redirects обрабатываются
- UI отображает кластер
- **Ноды кластера - реальные компоненты на канвасе (не строки в конфиге)**
- **Кластер формируется через соединения между компонентами**

---

### Этап 10: Метрики и мониторинг (Приоритет: ВЫСОКИЙ)

**Цель:** Расширить метрики до уровня реального Redis

**Задачи:**

1. **Дополнительные метрики:**
   - [x] Connected clients (детально) ✅ РЕАЛИЗОВАНО
   - [ ] Replication lag - ОТЛОЖЕНО (требует реализации репликации)
   - [x] Slowlog (топ медленных команд) ✅ РЕАЛИЗОВАНО
   - [x] Command statistics (по типам команд) ✅ РЕАЛИЗОВАНО
   - [x] Network I/O (bytes in/out) ✅ РЕАЛИЗОВАНО
   - [ ] Keyspace statistics (по базам данных) - ОТЛОЖЕНО (требует поддержки множественных БД)

2. **UI:**
   - [x] Расширенный дашборд метрик ✅ РЕАЛИЗОВАНО (новый таб Metrics)
   - [ ] Графики всех метрик - ОТЛОЖЕНО (можно добавить позже)
   - [x] Slowlog отображение ✅ РЕАЛИЗОВАНО
   - [x] Command statistics таблица ✅ РЕАЛИЗОВАНО

**Файлы для изменения:**
- `src/core/RedisRoutingEngine.ts` - добавить метрики
- `src/core/EmulationEngine.ts` - передача метрик
- `src/components/config/data/RedisConfigAdvanced.tsx` - отображение метрик

**Критерии готовности:**
- [x] Все метрики рассчитываются ✅
- [x] Метрики отображаются в UI ✅
- [ ] Графики работают корректно - ОТЛОЖЕНО

**СТАТУС: ✅ ЭТАП 10 ЗАВЕРШЕН (частично - основные метрики реализованы)**

---

## Приоритизация этапов

### Критично (делать в первую очередь):
1. **Этап 1: Расширение команд Redis** (особенно Streams - они объявлены, но не работают)
2. **Этап 6: Улучшение UI/UX**
3. **Этап 10: Метрики и мониторинг**

**Важно:** Streams объявлены как тип данных, но команды для них полностью отсутствуют. Это нужно исправить в первую очередь.

### Важно (делать во вторую очередь):
2. Этап 2: Pub/Sub
3. Этап 3: Transactions
7. Этап 7: Расширенные типы данных
9. Этап 9: Улучшение Cluster (особенно архитектура - ноды как реальные компоненты)

### Опционально (можно отложить):
4. Этап 4: Persistence симуляция
5. Этап 5: Replication
8. Этап 8: Lua Scripting

## Критерии качества

### Функциональность (10/10):
- [ ] Все основные команды Redis реализованы
- [ ] Все типы данных поддерживаются
- [ ] Pub/Sub работает
- [ ] Transactions работают
- [ ] Cluster работает корректно
- [ ] Persistence симулируется
- [ ] Replication симулируется

### UI/UX (10/10):
- [ ] Структура соответствует реальному Redis клиенту
- [ ] Все элементы интерактивны
- [ ] Визуализация данных удобна
- [ ] Графики метрик работают
- [ ] Адаптивность реализована
- [ ] Навигация интуитивна

### Симулятивность (10/10):
- [ ] Компонент влияет на метрики системы
- [ ] Метрики отражают реальное состояние
- [ ] Конфигурация влияет на поведение
- [ ] Интеграция с другими компонентами работает
- [ ] Latency рассчитывается реалистично
- [ ] Memory management работает корректно
- [ ] **Кластер симулятивен** - ноды кластера являются реальными компонентами на канвасе, а не строками в конфиге

## Найденные проблемы

### Критические (ИСПРАВЛЕНО):
1. ~~**Streams не реализованы**~~ ✅ ИСПРАВЛЕНО - все команды Streams реализованы
2. ~~**Инициализация не обернута в try-catch**~~ ✅ ИСПРАВЛЕНО - все инициализации обернуты
3. ~~**Много команд Redis отсутствуют**~~ ✅ ИСПРАВЛЕНО - основные команды реализованы

### Важные:

### Важные:
1. **Persistence не симулируется** - только настройки в UI, нет влияния на метрики
2. **Replication отсутствует** - нет master-replica функциональности
3. **Cluster упрощен** - нет slot migration, failover не симулируется
4. **Cluster ноды не симулятивны (КРИТИЧНО)** - ноды это строки в конфиге (`clusterNodes: string[]`), а не реальные компоненты на канвасе. 
   - **Проблема:** В реальном Redis каждая нода - отдельный экземпляр сервера. В симуляции должно быть так же.
   - **Текущая реализация:** Один компонент Redis с массивом адресов нод в конфиге
   - **Нужно:** Каждая нода - отдельный компонент Redis на канвасе, кластер формируется через соединения между компонентами
   - **Требует:** Переработка архитектуры кластера (см. Этап 9, пункт 3)

## Примечания

1. **Не использовать хардкод** - все значения из конфигурации
2. **Избегать скриптованности** - логика должна быть реалистичной
3. **Соответствовать реальности** - поведение должно соответствовать реальному Redis
4. **Каждый компонент уникален** - не копировать логику из других компонентов
5. **Защитное программирование** - валидация, обработка ошибок, дефолтные значения
6. **Инициализация должна быть обернута в try-catch** - согласно правилам курсора
7. **Кластер должен быть симулятивным** - ноды кластера должны быть реальными компонентами на канвасе, а не строками в конфиге. Кластер формируется через соединения между компонентами (см. Этап 9, пункт 3)
